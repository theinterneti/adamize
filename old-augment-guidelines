# Adamize Project Guidelines

## Project Overview

Adamize is a VS Code extension project focused on creating a development assistant similar to Augment Code but with specific differences and improvements. The project follows a test-driven development approach with a strong emphasis on DevOps best practices and integrates with local LLMs through the Model Context Protocol (MCP).

## Development Workflow

This project follows a STRICT test-driven development workflow. You MUST follow these steps in order:

1. Define requirements and acceptance criteria with clear requirement tags (REQ-XXX-YYY)
2. ALWAYS write tests BEFORE implementation code - tests MUST validate the requirements with corresponding test tags (TEST-XXX-YYY)
3. Run the tests to verify they FAIL (Red phase)
4. ONLY THEN implement code to pass the tests with implementation tags (IMPL-XXX-YYY)
5. Run the tests to verify they PASS (Green phase)
6. Refactor while maintaining test coverage
7. Document the implementation

### CRITICAL TDD RULES

- You MUST NEVER write implementation code without a failing test first
- You MUST NEVER create a new file without its corresponding test file
- You MUST ALWAYS run tests after making changes to verify they pass
- You MUST use the tagging system to maintain traceability between requirements, tests, and implementation
- You MUST commit code ONLY after tests are passing (Green phase)
- You MUST use the GREEN code-test pairs identification tools for staging and committing

### TDD Workflow Commands

- `npm run tdd` - Watch for changes and run tests automatically
- `npm run tdd:mcp` - Focus on MCP client implementation
- `npm run tdd:auto-stage` - Watch for changes and automatically stage passing tests
- `npm run tdd:auto-commit` - Watch for changes and automatically commit passing tests
- `npm run create:test` - Generate a new test file from template
- `npm run generate:tests` - Generate tests for a specific file
- `npm run generate:coverage-tests` - Generate tests based on coverage data
- `npm run generate:ai-tests` - Generate AI-powered tests for a specific file
- `npm run test:unit` - Run Jest unit tests
- `npm run test:unit:watch` - Run Jest tests in watch mode
- `npm run test:coverage` - Generate coverage reports
- `npm run identify:green` - Identify and stage passing tests and their implementations
- `npm run identify:green:commit` - Identify, stage, and commit passing tests
- `npm run identify:green:dry` - Dry run to see what would be staged/committed

## Code Standards

- TypeScript for all code
- ESLint for code linting
- Prettier for code formatting
- Jest for testing
- 100% test coverage for core functionality
- Documentation for all public APIs
- Strict TypeScript configuration
- Comprehensive type definitions
- Requirement tags for traceability
- Always use the newest possible versions of all dependencies

### Dependency Management Philosophy

- Use the newest possible versions of all dependencies
- Update dependencies one at a time, checking integration after each update
- Prefer explicit versioning in package.json
- Keep dependencies up-to-date with security patches
- Regularly review and update dependencies
- Adapt code to work with new major versions rather than staying on older versions
- Document breaking changes and migration steps

### Tagging System

- `REQ-XXX-YYY` - Requirement tags (e.g., REQ-MCP-001)
- `TEST-XXX-YYY` - Test tags (e.g., TEST-MCP-001)
- `IMPL-XXX-YYY` - Implementation tags (e.g., IMPL-MCP-001)

This tagging system ensures traceability between requirements, tests, and implementation code.

## Git Workflow

- Feature branches for all changes
- Pull requests for code review
- CI/CD pipeline must pass before merging
- Semantic versioning for releases
- Conventional commits for commit messages

### GREEN Code-Test Pairs Identification

The project includes a feature for identifying "green" code-test pairs (passing tests and their implementations) and staging them for commit. This supports the TDD workflow by making it easier to commit code at the right point in the TDD cycle.

- **Automatic Test Running**: Runs tests to identify passing tests
- **Implementation File Mapping**: Maps test files to their implementation files
- **Automatic Staging**: Stages passing tests and their implementations
- **Automatic Committing**: Optionally commits the staged files
- **Tag-Based Mapping**: Uses the project's tagging system to map tests to implementations

See `docs/dev/green-code-test-pairs.md` for detailed documentation.

### Procedural Test Generation

The project includes a feature for automatically generating tests based on source code analysis and coverage data. This helps developers follow the TDD workflow by providing a starting point for test files.

- **Source Code Analysis**: Analyzes TypeScript files to identify classes, methods, and requirement tags
- **Coverage Analysis**: Analyzes coverage data to identify uncovered code
- **Template Customization**: Supports different test templates (default, Jest, TDD, enhanced, ai-assisted)
- **VS Code Integration**: Integrated with VS Code through commands and context menu items
- **Coverage Visualization**: Highlights uncovered code in the editor

See `docs/dev/procedural-test-generation.md` for detailed documentation.

### Enhanced Template System

The project includes an enhanced template system for test generation that provides more flexibility and power.

- **More Template Variables**: Additional variables for more flexible templates (parameterList, returnType, etc.)
- **Variable Transformations**: Support for transforming variables (camelCase, pascalCase, snakeCase, kebabCase)
- **Conditional Blocks**: Support for conditional content based on variable values
- **Template Inheritance**: Support for templates that extend other templates
- **Custom Template Directories**: Support for loading templates from custom directories

See `docs/dev/enhanced-template-system.md` for detailed documentation.

### AI-Powered Test Generation

The project includes AI-powered test generation that uses local LLMs to generate more intelligent tests.

- **LLM Integration**: Integration with local LLMs (Ollama) for test generation
- **Code Understanding**: Better understanding of code purpose and behavior
- **Edge Case Detection**: Identification of potential edge cases
- **Improved Assertions**: Generation of more specific and meaningful assertions
- **Test Maintenance**: Support for updating tests when code changes

See `docs/dev/ai-powered-test-generation.md` for detailed documentation.

## MCP Client Implementation

The first feature to be implemented is an MCP (Model Context Protocol) client that will:

- Connect to MCP servers
- Discover available tools
- Call functions on tools
- Handle responses and errors

### MCP Client Requirements

- **REQ-MCP-001**: Connect to an MCP server via HTTP
- **REQ-MCP-002**: Discover available tools from the MCP server
- **REQ-MCP-003**: Retrieve the schema for a specific tool
- **REQ-MCP-010**: Call functions on tools with parameters
- **REQ-MCP-011**: Validate parameters against the function schema
- **REQ-MCP-012**: Handle successful function call responses
- **REQ-MCP-013**: Handle error responses from function calls
- **REQ-MCP-020**: Handle connection errors gracefully
- **REQ-MCP-021**: Handle tool discovery errors gracefully
- **REQ-MCP-022**: Handle schema retrieval errors gracefully
- **REQ-MCP-023**: Handle parameter validation errors gracefully
- **REQ-MCP-030**: Log connection attempts and results
- **REQ-MCP-031**: Log tool discovery attempts and results
- **REQ-MCP-032**: Log function calls and results
- **REQ-MCP-033**: Log errors with appropriate detail

## MCP Bridge Implementation

The MCP Bridge implementation adapts the ollama-mcp-bridge repository for use in our VS Code extension. It enables local LLM-powered agents to maintain and update a memory graph of project knowledge.

### MCP Bridge Components

- **VS Code Logger**: Replaces console-based logging with VS Code output channel ✅
- **Bridge Types**: Defines types for the MCP Bridge components ✅
- **MCP Bridge Client**: Handles communication with MCP servers ✅
- **LLM Client**: Handles communication with Ollama ✅
- **Tool Registry**: Manages tool registration and discovery (partially implemented)
- **MCP Bridge**: Core bridge component that manages tool registration and execution (partially implemented)
- **MCP Bridge Manager**: Manages the bridge lifecycle and integration with VS Code (partially implemented)

### MCP Bridge Requirements

- **REQ-LOGGER-001**: Replace console-based logging with VS Code output channel ✅
- **REQ-LOGGER-002**: Support different log levels (debug, info, warn, error) ✅
- **REQ-LOGGER-003**: Support log formatting ✅
- **REQ-LOGGER-004**: Support log filtering by level ✅
- **REQ-TYPES-001**: Adapt types to work with VS Code extension context ✅
- **REQ-TYPES-002**: Add VS Code-specific types ✅
- **REQ-TYPES-003**: Ensure compatibility with existing MCP types ✅
- **REQ-TYPES-004**: Add types for configuration management ✅
- **REQ-TYPES-005**: Support multiple connection methods ✅
- **REQ-TYPES-006**: Support multiple MCP servers ✅
- **REQ-MCPCLIENT-001**: Replace process spawning with VS Code-compatible approach ✅
- **REQ-MCPCLIENT-002**: Adapt JSON-RPC communication for VS Code ✅
- **REQ-MCPCLIENT-003**: Integrate with VS Code's output channel for logging ✅
- **REQ-MCPCLIENT-004**: Add support for multiple connection methods ✅
- **REQ-MCPCLIENT-005**: Ensure compatibility with existing MCP client ✅
- **REQ-MCPCLIENT-006**: Support tool discovery and registration ✅
- **REQ-MCPCLIENT-007**: Support function calling with parameter validation ✅
- **REQ-MCPCLIENT-008**: Handle connection errors gracefully ✅
- **REQ-MCPCLIENT-009**: Support multiple MCP servers ✅

## Ollama Integration

The Ollama integration enables the use of local LLMs through Ollama for various features in the Adamize VS Code extension. This integration is a key component of the MCP Bridge implementation.

### Ollama Integration Components

- **LLM Bridge Client**: Handles communication with Ollama ✅
- **Ollama Configuration View**: Provides a UI for configuring Ollama settings ✅
- **Ollama Commands**: Provides commands for starting, stopping, and configuring Ollama ✅
- **MCP Bridge Integration**: Integrates Ollama with the MCP Bridge (partially implemented)

### Ollama Integration Requirements

- **REQ-OLLAMA-001**: Connect to Ollama API ✅
- **REQ-OLLAMA-002**: Send prompts to Ollama and process responses ✅
- **REQ-OLLAMA-003**: Extract tool calls from Ollama responses ✅
- **REQ-OLLAMA-004**: Manage conversation history ✅
- **REQ-OLLAMA-005**: Start and stop Ollama from within VS Code ✅
- **REQ-OLLAMA-006**: Configure Ollama settings through VS Code settings ✅
- **REQ-OLLAMA-007**: Provide a UI for configuring Ollama settings ✅
- **REQ-OLLAMA-008**: Support multiple LLM providers (framework in place) ✅
- **REQ-OLLAMA-009**: Dynamically load available models from Ollama ✅
- **REQ-OLLAMA-010**: Test connection to Ollama ✅
- **REQ-OLLAMA-011**: Integrate with MCP tools (partially implemented)
- **REQ-OLLAMA-012**: Support streaming responses from Ollama (to be implemented)
- **REQ-OLLAMA-013**: Support model management (pulling, removing, etc.) ✅
- **REQ-OLLAMA-014**: Support advanced configuration options (to be implemented)
- **REQ-OLLAMA-015**: Support multiple models simultaneously (to be implemented)

### Ollama Model Management

The extension includes comprehensive model management capabilities for Ollama LLMs:

- **Model Discovery**: Automatically discovers available Ollama models
- **Model Pulling**: Allows pulling new models from Ollama
- **Model Removal**: Supports removing existing models
- **Server Control**: Start and stop the Ollama server from VS Code
- **Chat Integration**: Open chat interface with selected models
- **UI Integration**: Dedicated Model Manager view in the sidebar

#### Model Management Commands

The following commands are available for model management:

- `adamize.refreshModels`: Refresh the list of available models
- `adamize.pullOllamaModel`: Pull a new Ollama model
- `adamize.removeOllamaModel`: Remove an existing Ollama model
- `adamize.startOllama`: Start the Ollama server
- `adamize.stopOllama`: Stop the Ollama server
- `adamize.openOllamaChat`: Open the Ollama chat interface

These commands are accessible from the command palette, the Model Manager view, and context menus.

## Notion Integration

The Notion integration allows users to interact with Notion pages and databases directly from VS Code. This integration is designed to help developers maintain documentation, project plans, and knowledge bases alongside their code.

### Notion Integration Components

- **NotionClient**: Client for interacting with the Notion API (implemented but disabled)
- **NotionTool**: MCP tool for Notion operations (implemented but disabled)
- **NotionCommands**: VS Code commands for Notion operations (implemented but disabled)
- **NotionToolRegistration**: Registration of the Notion tool with the MCP bridge (implemented but disabled)

### Notion Integration Requirements

- **REQ-NOTION-001**: Connect to Notion API
- **REQ-NOTION-002**: Manage Notion API token
- **REQ-NOTION-003**: Perform CRUD operations on Notion pages
- **REQ-NOTION-004**: Provide VS Code commands for Notion operations
- **REQ-NOTION-005**: Implement UI for Notion operations
- **REQ-NOTION-006**: Provide MCP tool for Notion operations
- **REQ-NOTION-007**: Enable AI assistant to interact with Notion
- **REQ-NOTION-008**: Register Notion tool with MCP bridge

### Notion Integration Status

The Notion integration is currently marked as "coming soon" in the codebase. The basic structure and tests have been created, but they are disabled to avoid test failures. The integration will be enabled in a future release.

## Project Structure

- `src/` - Source code
  - `extension.ts` - Extension entry point
  - `mcp/` - MCP client implementation
    - `mcpClient.ts` - Main MCP client class
    - `mcpTypes.ts` - Type definitions
    - `mcpUtils.ts` - Utility functions
    - `bridge/` - MCP Bridge implementation
      - `vscodeLogger.ts` - VS Code Logger implementation
      - `bridgeTypes.ts` - Bridge type definitions
      - `mcpBridgeClient.ts` - MCP Bridge Client implementation
      - `llmClient.ts` - LLM Client implementation
      - `toolRegistry.ts` - Tool Registry implementation (partially implemented)
      - `mcpBridge.ts` - MCP Bridge implementation (partially implemented)
      - `mcpBridgeManager.ts` - MCP Bridge Manager implementation (partially implemented)
  - `ui/` - User interface components
    - `memoryGraphView.ts` - Memory graph visualization using Cytoscape.js
    - `mcpChatView.ts` - Chat interface for interacting with LLMs through MCP
    - `mcpServerExplorerView.ts` - VS Code sidebar view for managing MCP servers
    - `ollamaConfigView.ts` - UI for configuring Ollama settings
    - `coverageVisualizationProvider.ts` - Coverage visualization provider
  - `commands/` - VS Code commands
    - `testGenerationCommands.ts` - Test generation commands
  - `test/` - Test code
    - `suite/` - Test suites
      - `mcp/` - MCP client tests
        - `mcpClient.test.ts` - Tests for MCP client
        - `mcpUtils.test.ts` - Tests for utility functions
        - `bridge/` - MCP Bridge tests
          - `vscodeLogger.test.ts` - Tests for VS Code Logger
          - `mcpBridgeClient.test.ts` - Tests for MCP Bridge Client
          - `llmClient.test.ts` - Tests for LLM Client
          - `toolRegistry.test.ts` - Tests for Tool Registry (to be implemented)
          - `mcpBridge.test.ts` - Tests for MCP Bridge (to be implemented)
          - `mcpBridgeManager.test.ts` - Tests for MCP Bridge Manager (to be implemented)
      - `ui/` - UI component tests
        - `memoryGraphView.test.ts` - Tests for memory graph visualization
        - `mcpChatView.test.ts` - Tests for MCP chat interface
        - `mcpServerExplorerView.test.ts` - Tests for MCP server explorer
        - `ollamaConfigView.test.ts` - Tests for Ollama configuration view
    - `templates/` - Test templates
    - `setup.ts` - Test setup
    - `runTest.ts` - Test runner
- `docs/` - Documentation
  - `CONTRIBUTING.md` - Contribution guidelines
  - `dev/` - Development documentation
    - `research/` - Research documents
    - `green-code-test-pairs.md` - Documentation for GREEN code-test pairs identification
    - `procedural-test-generation.md` - Documentation for procedural test generation
    - `enhanced-template-system.md` - Documentation for enhanced template system
    - `ai-powered-test-generation.md` - Documentation for AI-powered test generation
  - `features/` - Feature documentation
    - `test-generation.md` - Documentation for test generation features
    - `ollama-integration.md` - Documentation for Ollama integration
  - `examples/` - Example code and usage
    - `test-generation-examples.md` - Examples of generated tests
- `templates/` - Template files
  - `test-templates.json` - Templates for test generation
  - `custom/` - Custom templates
    - `test-templates.json` - Custom test templates
- `scripts/` - Development scripts
  - `tdd.js` - TDD helper script
  - `create-test.js` - Test generator script
  - `identify-green-pairs.js` - GREEN code-test pairs identification script
  - `generate-tests.js` - Procedural test generator script
  - `generate-coverage-tests.js` - Coverage-based test generator script
  - `generate-ai-tests.js` - AI-powered test generator script
- `.devcontainer/` - Development container configuration
- `.github/` - GitHub workflows and templates
  - `workflows/` - GitHub Actions workflows
    - `ci.yml` - Continuous integration workflow
    - `release.yml` - Release workflow
    - `pr-validation.yml` - Pull request validation workflow

## Development Environment

The project uses a dedicated DevContainer for development to ensure consistency and isolation from the host system. The DevContainer includes:

- Node.js and npm
- TypeScript and ESLint
- VS Code extension development tools
- Docker for testing with containers
- Git for version control

## Testing Strategy

- Unit tests for all components
- Integration tests for the extension
- End-to-end tests for user workflows
- Coverage reports for all tests
- Automated testing in CI/CD pipeline

### MCP Client Test Plan

- **TEST-MCP-001**: Test that the client can connect to an MCP server successfully
- **TEST-MCP-001a**: Test that the client handles connection errors gracefully
- **TEST-MCP-002**: Test that the client can discover available tools from the MCP server
- **TEST-MCP-002a**: Test that the client handles tool discovery errors gracefully
- **TEST-MCP-003**: Test that the client can retrieve the schema for a specific tool
- **TEST-MCP-003a**: Test that the client handles schema retrieval errors gracefully
- **TEST-MCP-010**: Test that the client can call functions on tools with parameters
- **TEST-MCP-011**: Test that the client validates parameters against the function schema
- **TEST-MCP-011a**: Test that the client rejects invalid parameters
- **TEST-MCP-012**: Test that the client handles successful function call responses
- **TEST-MCP-013**: Test that the client handles error responses from function calls
- **TEST-MCP-030**: Test that the client logs connection attempts and results
- **TEST-MCP-031**: Test that the client logs tool discovery attempts and results
- **TEST-MCP-032**: Test that the client logs function calls and results
- **TEST-MCP-033**: Test that the client logs errors with appropriate detail

### MCP Bridge Test Plan

- **TEST-LOGGER-001**: Test that the logger can be created with an output channel
- **TEST-LOGGER-002**: Test that the logger logs messages at different levels
- **TEST-LOGGER-003**: Test that the logger formats messages correctly
- **TEST-LOGGER-004**: Test that the logger filters messages by level
- **TEST-MCPCLIENT-001**: Test that the client can connect to an MCP server via local process
- **TEST-MCPCLIENT-002**: Test that the client can connect to an MCP server via HTTP
- **TEST-MCPCLIENT-003**: Test that the client can connect to an MCP server via Docker exec
- **TEST-MCPCLIENT-004**: Test that the client can get available tools
- **TEST-MCPCLIENT-005**: Test that the client can call a tool
- **TEST-MCPCLIENT-006**: Test that the client handles connection errors gracefully
- **TEST-MCPCLIENT-007**: Test that the client handles tool call errors gracefully
- **TEST-MCPCLIENT-008**: Test that the client can close the connection
- **TEST-MCPCLIENT-009**: Test that the client integrates with VS Code's output channel

## UI Components

The project includes several UI components for interacting with MCP servers and visualizing data:

### MemoryGraphView

- **Purpose**: Visualizes the memory graph using Cytoscape.js
- **Features**:
  - Interactive graph visualization
  - Node and edge manipulation
  - Search functionality
  - Context menus for actions
- **Status**: Partially implemented, TypeScript errors fixed

### MCPChatView

- **Purpose**: Provides a chat interface for interacting with LLMs through MCP servers
- **Features**:
  - Send messages to LLMs
  - Display responses
  - Show tool executions in the chat
  - Maintain conversation history
  - Clear conversations
  - Select different MCP servers
- **Status**: Partially implemented, TypeScript errors fixed

### MCPServerExplorerView

- **Purpose**: Manages MCP servers in the VS Code sidebar
- **Features**:
  - List available MCP servers
  - Start/stop servers
  - Add new servers
  - View server details
  - View available tools
  - View tool details
- **Status**: Partially implemented, TypeScript errors fixed

### OllamaConfigView

- **Purpose**: Provides a UI for configuring Ollama settings
- **Features**:
  - Configure Ollama model and endpoint
  - Test connection to Ollama
  - Dynamically load available models
  - Configure temperature and max tokens
  - Configure system prompt
  - Support for multiple LLM providers (framework in place)
- **Status**: Fully implemented and tested

### UI Components Development Status

- All TypeScript errors have been fixed
- The UI components are partially implemented and now compile successfully
- The Ollama Configuration View is fully implemented and tested
- The extension can be packaged into a VSIX file
- The package size has been reduced by adding a .vscodeignore file
- The extension is now bundled with webpack for better performance

### Dependency Management

- The project uses the newest possible versions of all dependencies
- Dependencies should be updated one at a time, checking integration after each update
- Current dependency versions (as of last update):
  - TypeScript: 5.8.3
  - ESLint: 9.26.0
  - @vscode/vsce: 3.3.2
  - Jest: 29.7.0
  - Webpack: 5.91.0
- ESLint 9 configuration is in eslint.config.js using the new flat config format
- VS Code engine version is set to match the @types/vscode version

### Extension Bundling

- The extension is bundled using webpack to improve performance
- Webpack configuration is in webpack.config.js
- The bundled output is in the dist directory
- The main entry point in package.json points to dist/extension.js
- The .vscodeignore file excludes unnecessary files from the package
- Current package size: 1.62 MB (reduced from 3.68 MB)
- Current file count: 222 (reduced from 2150)

### Next Steps

1. Complete the implementation of the remaining UI components
2. Add more tests for the UI components
3. Implement the skipped tests
4. Complete the integration with Ollama for local LLM-powered agents:
   - Implement streaming responses from Ollama
   - ✅ Add model management features (pulling, removing models)
   - Enhance tool integration with Ollama
5. Improve the MCP Bridge implementation:
   - Complete the Tool Registry implementation
   - Complete the MCP Bridge implementation
   - Complete the MCP Bridge Manager implementation
6. Complete the Notion integration (currently marked as "coming soon"):
   - Fix test issues in the Notion integration
   - Complete the MCP Bridge integration for Notion
   - Implement UI components for Notion
   - Add database support
   - Create comprehensive documentation
7. Install the VSIX file in VS Code for testing
8. Add end-to-end tests for the Ollama and Notion integrations

## Documentation Requirements

- README.md with project overview and setup instructions
- CONTRIBUTING.md with contribution guidelines
- API documentation for all public interfaces
- User documentation for the extension
- Development guides for contributors
